---
title: JUC有关知识点
date: '2022/12/9 19:28'
swiper: false
swiperImg: 'https://zangzang.oss-cn-beijing.aliyuncs.com/img/iTab-1kz6jg.jpg'
cover: 'https://zangzang.oss-cn-beijing.aliyuncs.com/img/iTab-1kz6jg.jpg'
categories: JUC
sticky: 1
password: zangzang
message: 请输入密码才可访问
tags:
  - 并发
abbrlink: 6946007b
---

## Juc面经总结

### 什么是线程和进程

进程是一个程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，在java中我们启动main函数时其实就是启动了一个jvm的进程，而main函数所在的线程其实就是这个进程的一个线程，主线程

线程跟进程相似，但是线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程，与进程不同的是一个类的多个线程共享进程的堆和方法区，而每个线程又有自己的程序计数器，虚拟机栈，方法区栈，所以一个系统在场一个线程或是各个线程之间切换工作，消耗的资源要比进程小的多，所以线程被称为轻量级进程。

### 线程与进程的关系，区别和优缺点

线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各个进程是独立的，而各个线程则不一定，因为同一进程中的线程极有可能会互相影响。**线程执行开销小，但不利于资源的管理和保护**，而进程正好相反

### 程序计数器为什么是私有的

程序计数器主要有两个作用

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 在多线程下，程序计数器用于记录当前线程的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪里了

所以程序计数器私有为的是线程切换后能恢复到正确的执行 位置

### 虚拟机栈和本地方法栈为什么是私有的

- 虚拟机栈：每个java方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用到执行完成的过程，就对应着一个栈帧在java虚拟机栈中入栈和出栈的过程

所以为了保证线程中的局部变量不被别的线程访问到，对虚拟机栈和本地方法栈进行了私有。

### 并行与并发的理解

并发，就是一段时间内，多个任务都在执行(单位时间内不一定相同)；举个例子就是同一时间段内聊着两个女生，但是不一定两个同时聊，可能一会跟这个聊一会跟那个聊

并行，单位时间内，多个任务同时执行，举个例子，同时跟两个女生聊天，不过这次是一边和这个打电话聊天一边跟另一个打字聊天。

### 使用多线程可能带来什么问题

并发编程的目的就是为了能提高程序的运行效率和运行速度，但是并不是一直能够提高运行速度和效率，而且并发编程可能会遇到很多问题，比如内存泄漏、死锁、线程不安全等。

### 说说线程的生命周期和状态

Java线程在运行的生命周期中的指定时刻只可能处于下面6个不同状态的其中一个状态

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建但是还没有调用start方法                  |
| RUNNABLE     | 运行状态，Java线程将操作系统中的运行和就绪都称为‘运行中’     |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待状态，进入该状态表示当前线程，需要等待其他线程做特定动作唤醒 |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，他是可以在指定的世界自行返回的 |
| THRMINATED   | 终止状态，表示当前线程已经执行完毕                           |

线程创建之后他将处于new新建状态，调用start()方法后开始运行，线程这时候处于READY(可运行状态)。可运行状态的线程获得了CPU时间片后就处于RUNNING(运行状态)

当线程执行wait()方法之后，线程进入WAITING(等待)状态。进入等待状态的线程需要依据其他线程的通知才能够返回运行状态，而TIMED_WAITING(超时等待)状态相当于在等待状态的基础上增加了超时限制，比如sleep(long millis)方法可以将Java线程置于TIME_WAITING状态，当超时时间到店后Java线程将会回到runnable状态线程在执行 Runnable 的`run()`方法之后将会进入到 **TERMINATED（终止）** 状态。

### 为什么没有区分READY和RUNNING状态呢

现在的**时分**（time-sharing）**多任务**（multi-task）操作系统架构通常都是用**抢占式**轮转调度。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。

### 什么是上下文切换

上下文指的其实就是线程自己的运行**条件和状态**，比如程序计数器栈信息等，当出现如下情况的时候，线程会从占用cpu状态中退出

- 主动让出cpu，比如调用sleep()，wait()等
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用cpu导致其他线程或者进程饿死
- **调用了阻塞类型的系统中断，比如IO，线程被阻塞**
- 被终止或结束运行

其中前三种都会发生上下文切换，线程切换以为着要保存当前线程的上下文，留着在下一次占用cpu的时候恢复线程。并加载下一个将要占用cpu程序的上下文，这就是上下文切换。

每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下

### 产生死锁的4个必要条件

1. 互斥条件：该资源任意一个时刻只有一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才能释放资源
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

### 如何预防死锁

破坏死锁产生的必要条件即可：

1. 破坏请求与保持条件：一次性申请所有的资源
2. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动是否它占有的资源
3. 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件

### 说说sleep()方法和wait方法区别和共同点

- 最大的区别是sleep()没有释放锁资源，而wait方法释放了锁
- 两者都可以暂停线程的执行
- wait()主要用于线程间通信，sleep()通常用于暂停执行
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行后线程会自动苏醒，但是wait(long timeout)超实惠线程也会自动苏醒

### 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法

start()会执行线程响应的准备工作，然后自动执行run()方法，但是直接执行run()方法的话，会把run()方法当成一个主线程下的普通方法执行，并不会在某个线程中执行他

### 说一说对于synchronized关键字的了解

**synchronized**是为了防止多个线程对同一资源同时进行操作，**synchronized**可以保证被他修饰的代码块或者方法同一时间只能被一个线程访问

### 说一说自己是怎么使用synchronized关键字的

1. 修饰实例方法：作用于当前对象实例加锁，进入代码块之前要获得当前实例对象锁

   ![image-20220328080757424](C:\Users\25564\Desktop\学习社交\mysql\image-20220328080757424.png)

2. 修饰静态方法：也就是给当前的类加锁，会作用于当前类的所有实例对象，因为静态成员不属于任何一个实例对象而是属于类的成员，所以当我们的一个线程A调用非静态synchronized修饰的方法是，我们的b需要调用这个实例对象所属的类的静态synchronized方法是被允许的，不会发生互斥现象，因为访问非静态方法时所需的锁是当前实例对象的锁，而访问静态synchronized需要的是当前类的锁

3. 修饰代码块：指定加锁对象，给对象/类加锁![image-20220328081727811](C:\Users\25564\AppData\Roaming\Typora\typora-user-images\image-20220328081727811.png)

   指定方式，上边的表示需要当前的类对象锁，下边的表示需要当前的实例对象锁



​

### 单例模式了解吗手写一下，解释双检锁实现单例的原理

```java
/**
 * @author 臧臧 on 2022/3/28
 */
public class Singleton {
    private Singleton(){}
    public volatile static Singleton  instance = null;
    public static Singleton getInstance(){
        if (instance==null){
            synchronized (Singleton.class){
                if (instance==null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用volatile修饰instance也是很必要的，其实instance = new Singletion(); 其实是分三步执行的：

1. 为instance分配内存空间
2. 初始化instance
3. 将instance指向分配的内存地址

>由于JVM具有指令重排序的特性执行顺序有可能不是1->2->3,指令重排在单线程的环境下不会出现问题，但是在多线程环境下肯会出现一个线程获得还没有得到初始化的实例，假如线程T1执行了1和3，此时T2也调用了getInstance()发现此时instance不为空，因此返回instance，但是此时instance还未被初始化

### 讲一下sunchronized关键字的底层原理

**synchronized**同步语句块的实现使用的是**monitorenter**和**monitorexit**指令，其中**monitorenter**指向同步代码块的开始位置，**monitorexit**指令则指明同步代码块的结束位置。

在执行monitorenter时会尝试获得对象锁，如果当前锁的计数器为0则表示可以被获取，获取后将锁的技术器设为1也就是+1

![image-20220328085729413](C:\Users\25564\AppData\Roaming\Typora\typora-user-images\image-20220328085729413.png)

对象锁的拥有者线程才可以执行monitorexit指令来释放锁，在执行monitroexit指令后，将锁计数器设为0，表名锁被释放，其他线程可以尝试获取锁

synchronized修饰方法的时候并没有monitorenter指令和monitorexit指令，取而代之的确实ACC_SYNCHRONIZED标识，该表示指明了方法是一个同步方法。JVM通过该标识来辨别是否声明为同步方法，从而执行响应的同步调用

>synchronized锁主要是根据对象头中的markword和moniter锁来实现的，java锁是基于对象锁，每个对象都关联了一个moniter锁，对象在jvm中分为对象头，实例数据，对其方式三部分。
>
>对象头包含markword和类型指针，markword存储了对象的分代年龄，hashcode值，锁状态，锁记录，是否偏向，偏向线程id等信息，通过锁记录来关联monitor对象。
>
>monitor对象主要有owner，waitset，entryList，count四个属性。owner用来标识当前monitor对象属于哪个线程，waitset存储了等待状态的线程，entrylist存储了阻塞状态的线程。
>
>当多线程访问同步代码时，会进入到entryList中，线程通过CAS的方式将owner设为当前线程，计数器+1，修改失败的线程则进入阻塞状态。
>
>当线程执行了wait方法后，就会进入到waitset中等待，将owner设为null，并计数器-1。
>
>当线程执行notify或notifyAll方法时，会将WaitSet的线程加入到entryList中。
>
>当线程执行完代码后就会释放锁，计数器为0则代表锁被释放。

### synchronized和ReentrantLock的区别

1. synchronized是JVM层面的锁，ReentrantLock是API层面的锁
2. synchronized不需要用户手动去释放，ReentrantLock需要手动释放锁
3. synchronized是非公平的锁，ReentrantLock可以在构造方法中传入boolean进行选择，true为公平锁，false为非公平锁
4. ReentrantLock可以绑定Condition实现精确唤醒
5. synchronized锁的是对象，锁是保存在对象头里边的，根据对象头数据来表示是否线程拥有锁，而ReentrantLock锁的是线程，根据进入的线程和state标识锁的获取

### volatile关键字

这里先讲一下cpu高速缓冲存储器的工作方式

我们会先从内测中复制一份数据到缓存中，当cpu需要用到该数据时，就可以直接从缓存中取出，当运算完成后在将结果写到主存中，但是这样会存在**主存缓存不一致的问题**，比如就是两个线程同时进行i++操作，两个线程同时读到了i现在等于1，并对其++，然后写入主存中，现在主存中的i为2，但是正确结果为3

为了解决这个问题，就需要吧变量声明为volatile，这就指示jvm这个变量是共享且不稳定的每次使用他都要到主存中进行读取所以volatitle关键字除了防止JVM的指令重排，还有一个重要的作用就是保住变量的可见性

**禁止指令重排序原理**：

在被volatile修饰的变量在写指令后边会加上写屏障，会在读指令后边加上读屏障，

写屏障：写屏障之前的代码都会被同步到主存中，并且不可重排序到写屏障之后

读屏障：读屏障之后的代码都会读取主存的数据，并且代码不会重排序到读屏障之前

### 并发编程的三个重要特性

1. 原子性：一次操作或多次操作，要么所有操作都全部指向并且不被外界打扰，要么都不执行。通过synchronized保证
2. 一致性：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到最新的值，通过volatitle关键字保证共享变量的可见性
3. 有序性：代码在执行的过程中的先后顺序，通过jvm优化重排后，未必会按照我们的顺序执行，通过volatile可以禁止指令进行重排

### 说说synchronized关键字和volatitle关键字的区别

- volatitle关键字是线程同步的轻量级实现，所以volatitle性能肯定比synchronized关键字性能要号，不过他只能用于变量，synchronized可以修饰方法和代码块
- volatitle关键字可以保证数据的可见性，但是不能保证原子性，而synchronized既可以保证数据的可见性也可以保证数据的同步性
- volatitle关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是线程之间访问资源的同步性

### ThreadLocal

移步-------->https://zang.link/articles/97

### 线程池

#### 为什么要用线程池

- **降低资源消耗。**通过重复利用已经创建的线程，减少重复创建和销毁造成的消耗
- **提高响应速度。**当任务到达时，任务可以不需要等到线程创建就可以立即执行
- **提高线程的可管理型。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控

#### 线程池的参数

1. 线程池核心大小
2. 线程池最大数量
3. 生存时间
4. 时间单位
5. 阻塞队列
6. 线程工厂
7. 拒绝策略

#### ThreadPoolExecutor有哪些常用方法

- submit()/execute()：执行线程池
- shutdown()/shutdownNow()：终止线程池
- isShutdown()：判断线程是否终止
- getActiveCount()：正在运行的线程数
- getCorePoolSize()：获取核心线程数
- getMaximumPoolSize()：获取最大线程数
- getQueue()：获取线程池中的任务队列
- allowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程这些方法可以用来终止线程池、线程池监控等。

#### Runnable接口和Callable接口的区别

Runnable自Java1.0以来一直存在，但Callable仅在Java1.50中引入，为了就是来处理Runnable不支持的用例。Runnable接口不会返回结果或抛出检查异常，但是Callable接口可以所以，如果任务不需要返回结果或抛出异常推荐使用 **`Runnable` 接口** ，这样代码看起来会更加简洁。

#### 说说submit和execute两个方法区别

1. execute()方法用于提交不需要返回值的任务，所有无法判断任务是否被线程池执行成功与否
2. submiit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值,get()方法会阻塞当前线程直道任务完成，而使用

#### 如何创建线程池

《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

> Executor返回线程池对象的弊端如下：
>
> - **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。
> - **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

##### 方法一：通过构造方法实现

##### 方法二：通过Executor框架的工具类Executors来实现

- FixedThreadPool：该方法返回固定线程数量的线程池，该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，即立即执行，如果没有的话则新的任务会被暂存到一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
- SingleThreadExecutor：方法只有一个返回值的方法，当有多余线程被提交到该线程池中的时候，则会保存到一个任务队列中去，待线程空闲，按照陷入先出的顺序执行队列中的任务
- CacheThreadPool：该方法返回一个根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

#### 饱和策略

ThreadPoolExecutor饱和策略定义

如果当前同时运行的线程数达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor定义了一些策略：

- ThreadPoolExcutor.AbortPolicy：抛出RejectedExecutionException来聚集新任务的处理。
- ThreadPoolExcutor.CallerRunsPoilcy：这个就是回退，假如我们线程池中的可用已经满了，我们就进行线程的回退，这个回退呢就是main方法里边执行了方法然后线程池和阻塞队列都满了，就会给你的main线程去执行
- ThreadPoolExcutor.DiscardPolicy：不处理新任务直接丢掉
- ThreadPoolExcutor.DiscardOldestPolicy：丢弃最早未处理的请求任务



#### shutdownNow()和shutdown()两个方法有什么区别

都是用来终止线程池的，区别是shutdown()程序不会报错，也不会立即终止线程，他会等待线程池中的缓存任务执行完之后再退出，执行了shutdown()之后就不能给线程池添加新任务了；shutdownNow()会视图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出异常

--------------------------------------------------

### 介绍一下Atomic原子类

简单来说就是具有原子/原子操作的特征类，就是指一个操作是不可中断的，即使是在多个线程一起执行的时候，一旦操作开始执行，就不会被其他线程干扰。

### JUC包中的原子类是哪几类

基本类型

- `AtomicInteger`：整形原子类

​	volition无原子性，会将数据写丢

​	但是AtomicInteger可以不加锁，主要利用CAS+volition+native方法来保证原子性，从而避免了synchronized的高开销，执行效率大为提升



- `AtomicLong`：长整型原子类
- `AtomicBoolean`：布尔型原子类

数组类型

- `AtomicIntegerArray`：整形数组原子类
- `AtomicLongArray`：长整形数组原子类
- `AtomicReferenceArray`：引用类型数组原子类

引用类型



### 无锁

没有对资源进行锁定，所有线程都能够访问到同一资源，会出现两种情况

1. 某个线程不会出现在多线程的情况下

   即使出现了也不会出现竞争问题

无需进行保护，直接让各个线程进行调用即可

2. 资源会被竞争，但是我们不想对资源进行锁定，不过还是想通过一些机制来控制多线程

比如我们有三个线程一起对i进行操作，线程一成功了，线程b和c都失败了，此时bc都会一直进行失败重试，

就是使用CAS进行无锁编程，cas通过操作系统中通过一条指令来实现，所以能够保证原子性

### 偏向锁

此时我们给对象加锁，实际上运行时只有一个线程会获得这个对象锁，最理想的方式就是不通过线程切换并且不通过cas来获得锁，因为那样多多少少会消耗资源，我们设想的是对象能够认识这个线程，只要是这个线程过来，对象就直接把锁交出去，可以认为锁偏向这个线程，偏向锁是怎么实现的呢，很简单，在MarkWord中会有锁标志位

![image-20220330073848574](C:\Users\25564\AppData\Roaming\Typora\typora-user-images\image-20220330073848574.png)

当前markword的后两位是01的时候判断倒数第三个bit位是否是1，如果是1的话就说明就是一个偏向锁，如果当前为偏向锁，那么再去读他的前23个bit，这23个bit的值就是线程id，通过线程id来确认当前想要获得对象锁的这个线程，如果正确的话直接调用这个对象的资源，如果id为false则表示有多个线程正在竞争锁，则发生锁升级，升级为轻量级锁

### 轻量级锁

此时锁为轻量级的时候就不是再去判断当前锁的前23位线程id了，而是通过前25位有一个指向栈中锁记录的指针去判断，当一个线程想要获得某个对象锁的时候，假如看到锁标志位00那么就知道他是轻量级锁，此时会在虚拟机栈中开辟一块称为Lock Record的空间，吃吧存放的是对象头中MarkWord的副本以及owner指针，线程通过cas去尝试获得锁，一旦获得那么将会复制该对象头中的MarkWord到Lock Record中，并且将Lock Recod中的owner指针指向该对象，并且此时对象的前30位会生成一个指针指向线程虚拟机栈中的Lock Record，这样就实现了对象或者线程的绑定，这时候就可以去进行操作，但是如果现在有其他的线程来进行操作的话，那么就会进行自旋的等待，也就是线程自己在不断的尝试着去看一下对象的锁有没有被释放，如果释放了就进行获取，如果没有释放的话就进行轮询，区别于对操作系统挂起，因为如果对象的锁很快被释放的话，那么自旋就不需要进行系统的中断和现场的恢复，自旋相当于cpu在空转，如果长时间自旋会浪费cpu资源。，如果自旋等待的锁超过了一个那么就会升级为我们重量级的锁

### 悲观锁

简单的来说就是操作系统每次操作都会认为如果不严格的按照同步线程调用一定会出现异常，所以互斥锁会将资源锁定只给一个线程调用，而把其他的线程挡在外边，因此这种同步机制叫做悲观锁，但悲观锁会有缺点，那就是当我们的大部分操作都是读操作，那么就没有必要在每次调用的时候都锁定资源。

### 锁升级

锁状态分为，无锁->偏向锁->轻量级锁->重量级锁

1. 无锁状态使用cas来修改资源，每个线程都可以修改，但只要一个线程成功
2. 当一段代码块总是被一个线程访问的时候，无锁会升级为偏向锁，markword中会开启偏向状态和记录偏向线程id，以此减小cas带来的开销
3. 当偏向锁加入其它线程竞争时，会升级为轻量级锁。线程会生成锁记录空间，会存储markword的拷贝，jvm通过cas来修改markword指向锁记录的指针，没有获取到锁的线程会进入自旋等待。
4. 轻量级锁自旋超过一定次数或新加入了新的线程竞争，会升级为重量级锁，markword记录指向monitor对象的指针，没有获得到锁的线程会进入阻塞

### 可重入读写锁

ReentrantReadWriteLock

写锁和读锁是互斥的(这里的互斥指的是==线程间互斥==，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获得写锁)这是因为读写锁要保证写操作的可见性，如果不这样的话我们正在读的时候加了一个线程进行写，其他的线程无法知道当前写线程的操作。

可以多个线程同时读，

锁降级

会产生锁饥饿问题

### 邮戳锁

StampedLock

### CAS（compare and swap）

举个例子吧，假设一个场景，人物设定一个女神（资源），两个舔狗（线程），女神有个个牌子，表示他是否空闲，如果牌子为0就代表有空，可以和来找他的人共进晚餐，如果为1就代表不行，那么此时两个舔狗看到女神上的牌子是0，赶快都抢着过去舔，但是此时A舔狗先获得了时间片先到了女神身边将牌子翻为1，此时B舔狗过来结果已经被A抢先了看到牌子不是0，虽然很不服气，但是还得按照规则来。

现在我再讲CAS应该会很好理解，假设有一个资源i他的状态为0，此时两个线程都要对他操作，此时他们看到的i状态为0，假设A线程运气好先获得了时间片那么会将自己的old Value与资源的对象的状态值进行compare，发现一致于是将牌子上的值swap为new value1，此时a的时间片用完了，然后将自己的old Value与资源的对象的状态值进行compare，发现不一致，所以放弃了swap操作，在实际应用中并不会这样放弃，会让他进行自旋（不断的进行CAS操作，通常会配置自旋次数来防止死循环），就像b线程看到女神不跟自己一起吃饭，他不会简单放弃，他会在原地徘徊等待机会，当他意识到一个门老敲不开在敲就不礼貌了，就会放弃。并且CAS必须是原子操作，也就是说他这个比较和替换必须是原子性的，为什么呢，假设当我们a线程进行比较了之后还没有进行swap操作但是此时时间片轮换到b线程了，此时b一比较也是true，就会造成三个人一起约会，这种行为是不允许的。所以就有了原子类。

### AQS

#### 介绍

AQS的全称是抽象队列同步器，是一个用来构建锁和同步器的框架，想ReentrantLock，Semaphore，FutureTask都是基于AQS实现的。

#### 原理

简单来说AQS就是维护了一个共享资源，然后使用队列来保证线程获取资源的一个过程



AQS的工作流程：当被请求的共享资源空闲，那么直接将请求资源的线程设置为有效线程，如果共享资源不空闲的话，那么AQS就给我提供了一套阻塞队列等待以及唤醒线程时的锁分配的机制

这个队列是通过CLH实现的，该队列是一个双向队列，有node节点组成，每个node节点包含等待状态，线程信息，前驱节点，后继节点等信息，同时AQS还维护了两个指针Head和Tail，分别指向队列的头部和尾部

此外AQS使用了一个Volatile的int类型的State变量来表示同步状态。

#### 等待状态

| 枚举      | 含义                                             |
| :-------- | :----------------------------------------------- |
| 0         | 当一个 Node 被初始化的时候的默认值               |
| CANCELLED | 为 1，表示线程获取锁的请求已经取消了             |
| SIGNAL    | 为-1，表示线程已经准备好了，就等资源释放         |
| CONDITION | 为-2，表示节点在等待队列中，节点线程等待唤醒     |
| PROPAGATE | 为-3，当前线程处在 SHARED 情况下，该字段才会使用 |

#### 加锁流程

1. 如果state等于0，则会通过cas的方式修改state值，修改成功则获取到锁，将当前线程设为持有锁线程。（公平锁需要判断队列是否有其他线程）
2. 如果state不等于0，则判断当前线程是否持有锁，如果持有锁则将state+1
3. 如果获取锁失败，则新建node几点并且初始化till和head，并且自旋获取锁，判断前驱节点是否为头结点
4. 如果前驱节点为头结点，则会再次尝试cas修改state值，修改成功则会获取到锁
5. 如果前驱节点不为头节点或者修改失败，则获取前驱节点状态，判断是否需要阻塞当前线程。如果状态为SINGAL则阻塞当前线程，如果为CANCELLED则向前遍历移除cancel节点，如果为其他状态将前驱节点状态设为SINGAL。

#### 释放锁流程

1. 减少state值
2. 判断执行线程是否为持有锁的线程，不是则抛出异常
3. 如果state等于0，则代表锁被释放，将持有锁的线程设为null

#### 唤醒线程流程

1. 如果锁被释放，则会唤醒头结点的下一个节点
2. 如果头结点的下一个节点为空或者状态为CANCELLED，则会从后往前找到第一个不为CANCELLED的节点唤醒。

### 线程池

#### 底层原理

线程池遵循池化思想，通过将线程和任务分离的方式达到线程复用的效果。

线程池是基于生产者消费者模型设计，底层有一个线程集合和阻塞队列。

当任务提交时，会判断线程数量是否大于核心线程数，小于的话则直接创建线程运行任务，并保存到线程集合中。

大于的话则将任务添加到阻塞队列中，线程集合会不断从阻塞队列中取出任务运行。

当阻塞队列满的时候，会判断线程数量是否大于最大线程数，小于的话则创建救急线程，大于的话则执行拒绝策略。

急救线程会在取出任务时间超过keepAliveTime后进行回收，减少资源消耗