---
title: Redis底层数据结构详解
date: '2022/12/9 18:22'
swiper: true
swiperImg: 'https://zangzang.oss-cn-beijing.aliyuncs.com/img/20221209193002.png'
cover: 'https://zangzang.oss-cn-beijing.aliyuncs.com/img/20221209193002.png'
categories: redis
sticky: 1
tags:
  - cache
abbrlink: 11dc0777
---

## String
简单动态字符串
Redis默认字符串底层存储结构，比如set k1 v1，键k1是一个字符串，底层实现是保存着字符串k1的SDS，值v1也是一个字符串，底层实现是保存着字符串v1的SDS
底层使用c语言实现的他定义了一个结构体
```
struct sdshdr {
    //记录buf数组中已使用字节的数量，相当于保存的字符串的长度
    int len;  
    //记录buf数组中未使用的字节数量
    int free;
    //字节数组，用于保存字符串
    char buf[]
};
```
>优点，获取字符串长度的复杂度为O（1）
> 可以防止缓冲区溢出，因为其Api会进行空间扩展，扩展成之前的2倍也就是扩展之后free和len一样长
> 减少字符串修改时的内存重分配次数，因为有free（预分配），所有在最坏的情况下就是修改n次，重分配n次。

## List
底层是由quickList实现的，快速列表支持从链表投尾添加数据，并且可以获取指定位置的元素内容
### zipList
当列表中数据量较少时redis使用zipList来做列表的底层实现，压缩列表顾名思义是进行了压缩，每一个节点之间没有指针的指向，而是多个元素相邻，没有缝隙。所以 ziplist是Redis为了节约内存而开发的
### linkList
其实结构就和Java的linkList类似，Redis的linkedList双端链表有以下特性：节点带有prev、next指针、head指针和tail指针，获取前置节点、后置节点、表头节点和表尾节点、获取长度的复杂度都是O(1)。
>压缩列表占用内存少，但是是顺序型的数据结构，插入删除元素的操作比较复杂，所以压缩列表适合数据比较小的情况，当数据比较多的时候，双端列表的高效插入删除还是更好的选择
### quickList
快速列表，最后在Redis开发者的眼中，数据结构的选择，时间上、空间上都要达到极致，所以，他们将压缩列表和双端列表合二为一，创建了快速列表（quicklist）。和java中的hashmap一样，结合了数组和链表的优点。
list可以做消息队列，也可以实现消息排队
## set
set数据类型底层可以是intset(整数集)或者hashTable(散列表)
当数据都是整数并且数量不多时，使用intset作为底层数据结构；当有除整数以外的数据或者数据量增多时，使用hashtable作为底层数据结构。
## hash
Hash数据类型的底层实现是ziplist（压缩列表）或字典（也称为hashtable或散列表）。这里压缩列表或者字典的选择，也是根据元素的数量大小决定的。
当我们加入了字节数超过64的值的数据时，默认的数据结构已经成为了hashtable。

Hash对象只有同时满足下面两个条件时，才会使用ziplist（压缩列表）：

- 哈希中元素数量小于512个；
- 哈希中所有键值对的键和值字符串长度都小于64字节。
## Zset
Zset的底层是zipList或者skipList(跳表)，同样也是在数据量少的情况下会使用zipList，数据量大的情况下使用skipList
### 跳表
跳跃列表，顾名思义是可以跳的，跳着查询自己想要查到的元素。大家可能对这种数据结构比较陌生，虽然平时接触的少，但它确实是一个各方面性能都很好的数据结构，可以支持快速的查询、插入、删除操作，开发难度也比红黑树要容易的多。
对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。如果我们增加如下两级索引，那么它搜索次数就减小就像mysql的索引一样